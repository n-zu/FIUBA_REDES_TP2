Header FTP
tipo: upload (0) download(1) error (2) (dos bits, podemos usar un byte entero por simplicidad)
longitud: tamaño en bytes del archivo (segun wikipedia, un protocolo TLV tiene que tener longitud fija, pero podemos hacer como en MQTT y tener longitud variable)

Cliente
	Upload Header
	+------------------------+
	|Tipo: 0 (1 byte)		 |
	|Longitud (8 bytes)		 |
	|LongitudNombre (2 bytes)|
	+------------------------+



	Download Request Header
	+------------------------+
	|Tipo: 1 (1 byte)		 |
	|LongitudNombre (2 bytes)|
	+------------------------+

Servidor

	Download Header
	+------------------------+
	|Tipo: 2 (1 byte)		 |
	|Longitud (8 bytes)		 |
	+------------------------+

	Confirm Header
	+------------------------+
	|Tipo: 3 (1 byte)		 |
	+------------------------+

	Error Header
	+------------------------+
	|Tipo: 4 (1 byte)		 |
	|CodigoError (1 byte)	 |
	+------------------------+


Servidor - Recibo una nueva conexion:
Leo un byte del stream
Me fijo si es upload o download
Si es upload:
	Leo la longitud
	Si la acepto:
		Leo el nombre del archivo con que se debe guardar
		Creo el archivo donde voy a guardar la info
		Leo del stream (intento leer una cantidad determinada pero me puede llegar menos)
		Guardo la info leida en el archivo
		Repito hasta que los bytes leidos sean igual a la longitud
	Si no lo acepto:
		Mando un bloque tipo error, con el codigo de error

Si es download:
	Leo el nombre del archivo que me pide el cliente
	Abro el archivo
	Si existe el archivo:
		Envio primer bloque tipo download, con la longitud
		Divido el archivo en bloques
		sendall() por cada uno de los bloques

	Si no existe el archivo:
		Envio un bloque tipo error, con el codigo del error

Cierro la conexion
Nota: el cliente puede cerrar la conexion antes por distintos motivos, por ejemplo, si no acepta el archivo por ser muy grande


Cliente - Subir archivo:
Me conecto con el servidor
Mando por el stream el primer byte tipo upload
Mando la longitud (tamaño del archivo)
Mando el nombre del archivo con que se debe guardar
Divido el archivo en bloques
sendall() por cada uno de los bloques

Cliente - Descargar archivo:
Me conecto con el servidor
Mando por el stream el primer byte tipo download
Mando el nombre del archivo que quiero descargar
Leo del stream el primer byte
Si es tipo download:
	Leo la longitud (tamaño del archivo)
	Si lo acepto:
		Leo del stream (intento leer una cantidad determinada pero me puede llegar menos)
		Guardo la info leida en el archivo
		Repito hasta que los bytes leidos sean igual a la longitud
Si es tipo error:
	Leo el codigo del error

Cierro la conexion


RDTSocket - Stop and Wait:
Tipos de paquete: HELLO (0), PCKT, (1), ACK (2), FIN (3), FINACK (4) (1 byte)

CONNECT Header (sin body)
+------------------------+
|Tipo: 0 (1 byte)		 |
+------------------------+

CONNACK Header (sin body)
+------------------------+
|Tipo: 1 (1 byte)		 |
+------------------------+

INFO Header
+------------------------+
|Tipo: 2 (1 byte)		 |
|Longitud (16 bytes)	 | (longitud del BODY. Cuidado que no puede llegar a valer 64K)
|PCKT_N (4 bytes)		 |
+------------------------+

ACK Header (sin body)
+------------------------+
|Tipo: 3 (1 byte)		 |
+------------------------+


FIN Header (sin body)
+------------------------+
|Tipo: 4 (1 byte)		 |
+------------------------+

FINACK Header (sin body)
+------------------------+
|Tipo: 5 (1 byte)		 |
+------------------------+


Bind:
Me guardo la ip y puerto del servidor

Connect:
Mando paquete tipo HELLO
Espero recibir un paquete tipo HELLO
No hay info para setear sobre el server en este caso

Accept:
Espero paquete tipo HELLO
Cuando llega, respondo con HELLO
Creo un socket (SAW o SR) con la ip y puerto del cliente (tambien le paso ip y puerto del servidor)
Devuelvo el socket

Send:
Divido el buffer en paquetes
Mando paquete tipo PCKT con numero de paquete (el primero es 0) por el send_channel
Espero recibir un paquete tipo ACK por el send_channel con el mismo numero de paquete
Si no recibo el ACK y da timeout, reenvio el paquete (tipo PCKT de nuevo)
Si el numero de paquete no coincide, asumo que es de un paquete viejo demorado en la red

Si recibo el ACK, mando el siguiente
Repito hasta que
- Haya timeout
- Envie todos los bytes
En ambos casos retorno con exito y la cantidad de bytes recibidos


Recv:
Espero un paquete tipo PCKT por el recv_channel
Chequeo que el numero de paquete coincida con el esperado
Si no coincide, asumo que es un paquete demorado en la red, y lo descarto (no mando ACK)
Si coincide, mando un paquete tipo ACK

Repito hasta que
- Haya timeout
- Llene el buffer
En ambos casos retorno con exito y la cantidad de bytes recibidos


Close:
Mando un paquete tipo FIN por el send_channel
Espero un ACK




MuxDemux:
conexiones (diccionario {(ip, puerto): channel})
queue [(ip, puerto)]

Bind:
Bindeo el socket UDP

Listen:
Seteo la cantidad de conexiones pendientes que puedo tener en la cola (sin aceptar) antes de rechazarlas
Creo un thread que va a estar recibiendo del socket udp
Thread:
	Cuando recibe un paquete udp, me fijo la ip y puerto
	Si ya estan en 'conexiones":
		Si hay lugar en el channel, lo mando por el channel
		Si no hay lugar lo descarto y no hago nada mas
	Si no esta en conexiones:
		Si la cola de conexiones no esta llena, agrego (ip, puerto) a la lista
	Repito hasta que se cierre el socket (otro channel para saber cuando se cierra?)


Accept:
Si hay algun elemento en la cola:
	Lo saco de la cola
	Creo un nuevo channel
	Creo un nuevo MuxDemux con ese channel
	Agrego el channel al diccionario de conexiones
	Devuelvo el MuxDemux
Si no hay elementos en la cola:
	Espero hasta que haya alguno (timer seria la opcion mas facil)


Send:
Agrego magic number al buffer (tengo que chequear que el paquete final entre por UDP)
Manda los bytes por udp

Recv:
Depende si es un socket de server (Bind -> Accept) o de cliente (Bind -> Connect) Rust los separa en TCPListener y TCPStream
Si es de server:
	Me fijo en mi channel usando la ip y puerto (del cliente) si hay un paquete
	Si hay un paquete, pruebo meterlo en el bufer
	Si no entra tiro error
	Si entra devuelvo los bytes totales recibidos

Si es de cliente:
	Recibo un paquete por UDP
	Chequeo el magic number del protocolo (4 bytes?)
	Si es correcto, meto los bytes en el buffer (sin el magic number)

Connect:
Mando un paquete CONNECT con magic number (UDP ya manda ip y puerto, el puerto me lo asigna automaticamente)
Espero recibir un paquete CONNACK con magic number
Si tira timeout lo vuelvo a mandar































